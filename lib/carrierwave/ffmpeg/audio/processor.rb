require "fileutils"

module CarrierWave
  module Ffmpeg
    module Audio
      class Processor
        DefaultOptions = {
          bit_rate: "128k",
          sample_rate: "44100",
        }

        # Scope these under Processor so you can catch the ones generated by just this class.
        class RuntimeError < ::RuntimeError;end;
        class ArgumentError < ::ArgumentError;end;

        class << self
          def convert(source, options)
            options = DefaultOptions.merge(options)
            final_filename = tmp_filename(source: source, format: "mp3")
            system "ffmpeg -i #{source} -c:a libmp3lame -ab #{options[:bit_rate]} -ar #{options[:sample_rate]} #{final_filename}"
            final_filename
          end

          def watermark(source, options)
            options = DefaultOptions.merge(options)
            watermark_file_path = options[:watermark_file]

            raise ArgumentError.new("No watermark filename given, must be a path to an existing sound file.") unless watermark_file_path
            raise RuntimeError.new("Watermark file '#{watermark_file_path}' not found.") unless File.exist?(watermark_file_path)

            final_filename = tmp_filename(source: source, format: "mp3", prefix: "wtmk")
            system "ffmpeg -i #{source} -i #{watermark_file_path} -filter_complex amerge -c:a libmp3lame -ab #{options[:bit_rate]} -ar #{options[:sample_rate]} #{final_filename}"

            final_filename
          end

          private

          # Generate a temporary filename
          def tmp_filename source:, format:, prefix: nil
            ext = File.extname(source)
            source_filename_without_ext = File.basename(source, ext)
            File.join File.dirname(source), "tmp#{prefix.present? ? '_' + prefix : ''}_#{source_filename_without_ext}_#{Time.now.to_i}.#{format}"
          end
        end
      end
    end
  end
end
